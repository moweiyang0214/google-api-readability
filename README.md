# Google AIP: API Readability
source: [https://github.com/aip-dev/google.aip.dev](https://github.com/aip-dev/google.aip.dev)

## AIP-122：资源名称 (Resource Names)

* **核心概念：** 定义 API 资源的统一资源标识符（URI），确保资源的唯一性、可寻址性和可预测性。
* **结构：** 资源名称通常遵循一种分层结构，交替出现集合标识符和资源标识符。
  * **格式：** `collection_id/{resource_id}/collection_id/{resource_id}`
  * **示例：** `publishers/123/books/456`, `projects/my-project/topics/my-topic`
* **资源标识符 (Resource ID) 的设计：**
  * **字符限制：** **应**限制为 ASCII 字符，不应包含需要 URL 转义的字符。**建议**只包含小写字母（a-z）、数字（0-9）和连字符（-），并且**必须**以小写字母开头。
  * **唯一性：** 在其父级集合中必须是唯一的。
  * **不透明性：** 客户端**不应**尝试解析或重构资源名称的内部结构，而应将其视为不透明字符串进行存储和使用。这有助于 API 在未来进行命名约定更改时，避免破坏客户端代码。
* **资源名称的唯一性范围：**
  * **完整资源名称 (Full Resource Names)：** 包含服务名称（例如 `//service.googleapis.com/projects/my-project/topics/my-topic`）在所有 Google API 范围内**是唯一**的。这是保证全球唯一性的关键。
  * **相对资源名称 (Relative Resource Names)：** 不包含服务名称（例如 `projects/my-project/topics/my-topic`）**不是**全局唯一的，不同的服务可能使用相同的相对名称模式。

## AIP-126：枚举 (Enums)

* **核心概念：** 提供一套关于在 Protobuf 中设计和使用枚举的规范，以确保清晰、一致的表示离散状态或类型。
* **命名约定：**
  * **枚举类型名：** 通常使用 PascalCase（如 `State`, `BookFormat`）。
  * **枚举值：** **必须**使用 `UPPER_SNAKE_CASE`（全大写，单词间用下划线分隔）。
  * **零值：** 每个枚举的第一个值（零值，即 `0`）**应该**是 `UNSPECIFIED`（如 `STATE_UNSPECIFIED = 0`），用于表示未指定状态，不应在实际业务逻辑中使用。
* **组织和范围：**
  * **嵌套：** 仅在单个消息中使用的枚举**应该**嵌套在该消息内部。这提高了局部性、可读性，并避免了全局命名空间污染。
  * **顶层枚举：** 如果枚举在多个消息或 RPC 中通用，则可以作为顶层定义。
* **兼容性：**
  * **添加值：** 向现有枚举添加新值通常被认为是**向后兼容**的更改。客户端应编写代码来优雅地处理未知枚举值。
  * **删除/重命名/重排值：** 删除、重命名或重新排序现有枚举值是**破坏性更改**，应避免在同一主版本中进行。
  * **命名空间冲突：** 同一 Protobuf 包（或命名空间）下的多个顶层枚举**不得**共享相同的值名，以避免 C++ 等语言生成的代码冲突。
* **适用场景：** 枚举适用于表示一组有限、预定义的常量值，尤其适用于：
  * **状态：** 如任务的 `SUCCEEDED`, `FAILED`, `RUNNING`。
  * **类型/格式：** 如文件格式（`.csv`, `.xls`），认证类型。
  * **标准代码：** 如货币代码（`USD`, `EUR`），语言代码（`en`, `fr`）。

## AIP-133：创建标准方法 (Create Standard Method)

* **核心概念：** 定义用于创建资源的标准化 RPC 方法，确保一致性和可预测性。
* **RPC 命名：** 通常为 `Create{ResourceName}` (例如 `CreateBook`)。
* **HTTP 映射：**
  * **HTTP 动词：** **必须**是 `POST`。
  * **URI：** 通常映射到集合路径（例如 `/v1/publishers/{publisher_id}/books`）。
  * **请求体：** 通常包含要创建的资源本身的数据（例如 `body: "book"` 或 `body: "*"`）。
* **请求消息：**
  * 包含 `parent` 字段（指定父级资源，通常是 URI 路径的一部分）。
  * 包含要创建的资源实例字段（例如 `book`）。
  * **用户指定 ID：** 如果允许用户指定资源的 ID，请求消息中会有一个单独的 ID 字段（例如 `book_id`）。在 REST API 中，该 ID 字段通常作为 **URI 查询参数**（例如 `POST /v1/{parent=publishers/*}/books?book_id=my-book-id`）提供，而不是 URI 路径的一部分。
* **响应消息：** 通常返回新创建的资源实例本身。

## AIP-135：删除标准方法 (Delete Standard Method)

* **核心概念：** 定义用于删除单个资源的标准化 RPC 方法。
* **RPC 命名：** 通常为 `Delete{ResourceName}` (例如 `DeleteBook`)。
* **HTTP 映射：**
  * **HTTP 动词：** **必须**是 `DELETE`。
  * **URI：** 通常映射到特定资源的路径（例如 `/v1/publishers/{publisher_id}/books/{book_id}`）。
* **响应消息：**
  * 通常**应该**是 `google.protobuf.Empty`。
  * **软删除 (Soft Delete)：** 如果 API 支持软删除（资源被标记为已删除但仍可恢复），则 `Delete` 方法**应该**返回更新后的资源（通常包含 `delete_time` 字段），而不是 `google.protobuf.Empty`。
* **长时间运行的删除：** 如果删除操作预计会耗时较长（例如，涉及大量级联删除），API **应该**返回 `google.longrunning.Operation`，客户端可以通过它跟踪删除进度。

## AIP-146：通用字段 (Generic fields)

* **核心概念：** 提供了在 API 中处理可变类型或任意结构数据的字段设计模式，强调在灵活性和类型安全之间取得平衡。**通常应谨慎使用，优先选择更具体、类型安全的方法。**
* **设计模式：**
  1.  **`oneof` (类型联合)：**
      * **用途：** 表示在多个字段中**只能有一个**字段被设置的情况。
      * **优点：** 保持了最大的类型安全和语义清晰度。适用于选项数量有限且已知的情况。
      * **兼容性：** 向现有 `oneof` 添加新的可选字段是向后兼容的。但将字段移入或移出 `oneof` 是**破坏性更改**。
  2.  **`map<key_type, value_type>` (映射)：**
      * **用途：** 适用于需要许多**相同类型**的值，但键是未知或用户确定的情况（例如，存储配置属性的键值对）。
      * **局限性：** 值类型是固定的，不适用于值类型本身可变的情况。
  3.  **`google.protobuf.Struct`：**
      * **用途：** 可以表示任意嵌套的 JSON 结构（包含键值对，值可以是基本类型、数组或嵌套结构体）。
      * **适用场景：** 当服务提前不知道数据模式，或需要存储和检索任意但有结构的用户数据时。
      * **用户便利性：** 方便客户端直接操作 JSON 对象。
      * **模式推理：** 如果需要推断 `Struct` 的模式，应使用 JSON Schema。
  4.  **`google.protobuf.Any`：**
      * **用途：** 可以封装任意序列化的 Protobuf 消息及其类型定义。
      * **缺点：** 引入显著复杂性。要求消费者能够访问并理解封装的 Protobuf 消息定义，通常需要额外的类型注册和手动反序列化过程。
      * **优先级：** **不应**优先使用 `Any`，除非其他所有选项都不可行。

## AIP-151：长时间运行操作 (Long-running operations)

* **核心概念：** 定义处理 RPCs 的模式，这些 RPCs 在单个响应中无法快速完成，允许客户端异步跟踪其进度和最终结果。
* **返回类型：** 对于任何预计需要长时间（超过几秒钟）才能完成的 RPC，**必须**返回 `google.longrunning.Operation` 消息。
* **`operation_info` 选项：**
  * 在 RPC 定义中，使用 `option (google.longrunning.operation_info) = { ... };` 来指定操作完成后的实际响应类型和操作过程中的元数据类型。
  * **`response_type`：** 指定操作成功完成时，`Operation.response` 字段中包含的 Protobuf 消息的类型。
  * **`metadata_type`：** 指定 `Operation.metadata` 字段中包含的 Protobuf 消息的类型，用于提供操作的实时进度信息。

## AIP-153：导入和导出 (Import and export)

* **核心概念：** 提供如何设计数据导入（将数据载入 API）和导出（将数据从 API 传出）操作的指南，尤其适用于大量数据场景。
* **RPC 命名：** 通常为 `Import{ResourceCollection}` 或 `Export{ResourceCollection}`（例如 `ImportBooks`, `ExportBooks`）。对于单个资源的数据操作，命名可能为 `Import{ResourceName}{DataType}`（例如 `ImportPages`）。
* **返回类型：** 通常返回 `google.longrunning.Operation`，因为这些操作可能耗时较长。
* **HTTP 映射：**
  * **HTTP 动词：** **必须**是 `POST`。
  * **URI 后缀：**
    * 导入通常使用 `:import`（例如 `/v1/publishers/{publisher_id}/books:import`）。
    * 导出通常使用 `:export`（例如 `/v1/publishers/{publisher_id}/books:export`）。
    * 对于单个资源的数据操作，后缀包含动词和数据名词（例如 `/v1/books/{book_id}:importPages`）。
  * **请求体：** **必须**是 `"*"`，表示整个请求体是资源。
* **请求对象：**
  * **来源/目的地配置：** 使用 `oneof source`（导入）或 `oneof destination`（导出）字段来明确指定来源或目的地。即使只有一个选项，也**必须**使用 `oneof` 以保持未来扩展性。
  * **通用配置：** 适用于所有来源或目的地的配置（如认证、错误处理策略）应放置在请求消息的顶层。
* **部分失败：**
  * 尽管通常不鼓励部分失败，但导入和导出 RPC **应该**在 `Operation` 的元数据对象中包含部分失败信息（通常以 `google.rpc.Status` 列表形式）。

## AIP-156：单例资源 (Singleton resources)

* **核心概念：** 定义一种特殊的资源类型，它在其父级资源下有且仅有一个实例。常见用于表示父级资源的配置或设置。
* **命名：**
  * **无 ID：** 单例资源**不得**拥有用户提供或系统生成的 ID。
  * **名称格式：** 其资源名称包含其父级资源的名称，后跟一个静态的集合标识符。
  * **示例：** `users/1234/settings`, `projects/my-project/config`
  * **Protobuf 定义：** 在 Protobuf 定义中，资源名称字段**总是**使用单数形式，但其 `google.api.resource` 选项**必须**同时提供 `singular` 和 `plural` 字段。
* **允许/禁止的标准方法：**
  * **禁止：** 单例资源**不得**定义 `Create` 或 `Delete` 标准方法，因为它们只能存在一个且不能被销毁。
  * **允许：** 单例资源**应该**定义 `Get` 和 `Update` 标准方法。
  * **可选：** **可以**定义 `List` 方法，但这需要遵循 [AIP-159：跨集合读取](https://google.aip.dev/159) 的规定，因为 `List` 旨在列出集合中的多个资源。

## AIP-158：分页 (Pagination)

* **核心概念：** 提供一套标准方法，用于在 API 返回大量结果时，客户端分批请求数据。
* **请求字段：**
  * **`page_size` (int32)：** 客户端请求的每页结果数量。
    * 服务器**应该**尊重此值，但**必须**将其限制在合理的最大值（例如 1000）。
    * 如果用户指定的值超过最大值，服务器**应该**强制使用最大值（而不是报错），并在响应中指示实际使用的页面大小。
  * **`page_token` (string)：** 服务器返回的不透明令牌，用于请求下一页结果。
* **响应字段：**
  * **`next_page_token` (string)：** 如果有更多结果，服务器会返回此令牌。如果令牌为空或缺失，则表示没有更多结果。
* **`page_token` 的特性：**
  * **不透明性：** `page_token` **必须**是不透明的。客户端不应尝试解析或理解其内部结构。
  * **类型：** 可以是字符串或字节（通常在 HTTP/JSON 中编码为字符串），只要 API 保持一致。
* **客户端行为：**
  * 客户端应始终检查 `next_page_token` 来判断是否有更多结果，而不是依赖于接收到的结果数量是否小于请求的 `page_size`。
* **兼容性：** 向现有 `List` 或 `Search` 方法添加分页参数（`page_size`, `page_token`）通常是**向后兼容**的，因为这些参数通常是可选的。

## AIP-164：软删除 (Soft delete)

* **核心概念：** 提供一种机制，允许用户“删除”资源，但不是立即永久删除，而是将其标记为已删除状态，以便将来可以恢复。主要目的是防止用户意外删除数据。
* **`Delete` 方法的行为：**
  * 如果资源支持软删除，`Delete` 方法**必须**仅仅将资源标记为已删除（例如设置 `delete_time` 字段），而不是从系统中完全移除。
  * `Delete` 方法**应该**返回更新后的资源（而不是 `google.protobuf.Empty`），以反映其新的已删除状态。
* **资源字段：**
  * 支持软删除的资源**应该**包含 `google.protobuf.Timestamp delete_time` 字段，表示资源被标记为删除的时间。
  * **可以**包含 `google.protobuf.Timestamp purge_time` 字段，表示资源将被彻底清除的时间。
  * 如果资源包含 `state` 字段，它**应该**包含一个 `DELETED` 状态值。
* **`Undelete` 方法（恢复删除）：**
  * 支持软删除的资源**应该**提供一个 `Undelete` 方法。
  * **RPC 命名：** `Undelete{ResourceName}` (例如 `UndeleteBook`)。
  * **HTTP 动词：** **必须**是 `POST`。
  * **请求体：** **必须**是 `"*"`。
  * **响应：** **必须**是资源本身（例如 `Book`），而不是一个单独的响应消息。
  * **长时间运行：** 如果 `Undelete` 操作耗时较长，应返回 `google.longrunning.Operation`，其最终结果为资源本身。
  * **请求消息：** 通常只包含一个 `name` 字段，指向要恢复的资源。
* **`List` 和 `Get` 行为：**
  * **`List` (默认)：** 软删除的资源**不应**默认在 `List` 响应中返回。API 可以提供一个可选的 `bool show_deleted` 字段让用户显式请求包含它们。
  * **`Get`：** 对软删除资源的 `Get` 请求**应该**返回资源本身（而不是 `NOT_FOUND` 错误），并指示其已删除状态。
* **声明式友好资源：** 软删除资源在声明式客户端（例如 IaC 工具）中的管理可能不如硬删除资源直观，因为软删除引入了复杂的中间状态。
* **错误处理：**
  * `PERMISSION_DENIED` (403)：用户没有权限访问资源时返回。
  * `NOT_FOUND` (404)：用户有权限但资源不存在或已被彻底清除时返回。
  * `ALREADY_EXISTS` (409)：用户尝试恢复一个未被删除的资源时返回。

## AIP-165：基于条件的删除 (Criteria-based delete)

* **核心概念：** 一种非常规的批量删除模式，允许根据过滤条件删除大量（数千或更多）资源。**应作为最后的手段，不应普遍采用。**
* **不鼓励的原因：** 删除操作通常不可逆，这种模式容易导致用户意外丢失大量数据。
* **适用场景：** 只有当标准删除（[AIP-135](https://google.aip.dev/135)）或批量删除（[AIP-235](https://google.aip.dev/235)）模式不足以删除海量资源时，才**可以**使用。
* **RPC 命名：** **必须**以 `Purge` 开头，后跟要清除资源的复数形式（例如 `PurgeBooks`）。
* **返回类型：** **必须**返回 `google.longrunning.Operation`。
* **HTTP 映射：**
  * **HTTP 动词：** **必须**是 `POST`。
  * **请求体：** **必须**是 `"*"`。
  * **URI 路径：** **应该**代表资源的集合（例如 `/v1/publishers/{parent}/books:purge`）。
* **请求消息字段：**
  * **`parent` (string)：** **应该**包含，指定父级资源。
  * **`filter` (string)：** **必须**包含，**应该**被标记为 `REQUIRED`，并遵循与 `List` 方法相同的过滤语义。空过滤器**不应**表示删除所有。
  * **`force` (bool)：** **必须**包含。
    * 如果 `false`（默认值）：执行试运行（Dry Run），API 返回将要删除的资源数量和样本，不实际删除。
    * 如果 `true`：实际执行删除操作。
* **响应消息字段（在 `Operation.response` 中）：**
  * **`purge_count` (int32)：** **应该**包含已删除或将要删除的资源数量（可以是估计值）。
  * **`purge_sample` (repeated string)：** **应该**包含一个将要删除的资源名称样本（如果 `force` 为 `false`）。样本大小通常为 100 个。

## AIP-180：向后兼容性 (Backwards compatibility)

* **核心概念：** 维护 API 与用户之间的“合同”，确保在 API 更新到新的次要或补丁版本时，现有客户端代码不会中断。旧客户端必须能与新服务器（在相同主版本号下）正常通信。
* **三种兼容性类型：**
  1.  **源代码兼容性：** 针对旧版本编写的代码能针对新版本编译并运行。
  2.  **连线兼容性 (Wire compatibility)：** 针对旧版本编写的代码能与新服务器正确通信（序列化/反序列化匹配）。
  3.  **语义兼容性：** 针对旧版本编写的代码能继续接收合理开发者所期望的结果。
* **允许的变更 (在同一主版本中)：**
  * **添加新组件：** 通常**可以**添加新的接口、方法、消息、字段、枚举或枚举值。
    * **限制：** **不得**向现有请求消息或资源添加新的**必填**字段。
    * 新添加的客户端填充字段的默认行为**必须**与引入该字段之前行为匹配。
* **禁止的变更 (在同一主版本中) — 均为破坏性更改：**
  * **移除/重命名：** **不得**移除或重命名现有组件（语义上等同于“移除并添加”）。
  * **移动：** **不得**在文件间移动现有组件。
  * **`oneof` 更改：** **不得**将现有字段移入或移出 `oneof`。
  * **类型更改：** **不得**更改现有字段和消息的类型，即使是连线兼容的。
  * **资源名称更改：** 资源**不得**更改其名称或名称的有效集合。
  * **语义更改：** **不得**以可能破坏合理用户代码的方式更改可见行为或语义。
  * **默认值更改：** **不得**更改字段的默认值。
  * **序列化默认值更改：** **不得**更改具有默认值的字段的序列化方式（例如，默认值字段不应从省略变为显示）。

## AIP-181：稳定性级别 (Stability levels)

* **核心概念：** 定义 API 组件（方法、资源、字段等）的不同成熟度阶段，以及每个阶段对应的稳定性期望和变更策略。
* **级别：**
  1.  **Alpha：**
      * **迭代速度：** 允许快速迭代，预期并允许**破坏性变更**。
      * **用户期望：** 用户**必须**对稳定性没有期望。
      * **用户限制：** **应该**限制在明确允许的已知用户列表（通过白名单），以便易于管理和沟通。
  2.  **Beta：**
      * **成熟度：** 功能完整，已准备好进行公开测试。
      * **用户开放：** **应该**向公众开放，不限制用户列表。
      * **稳定性期望：** 应该尽可能稳定。**可以**包含向后不兼容的变更，但**必须**遵循合理的弃用期。
      * **时间限制：** **应该**有时间限制（例如 90 天），不应无限期保持 Beta 状态。
  3.  **Stable (稳定)：**
      * **支持承诺：** 在其主要 API 版本的整个生命周期内**必须**得到全面支持。
      * **破坏性变更：** **必须**没有破坏性变更，除非在极端情况下（如下所述）。
      * **下线流程：** 在 API 标记为稳定时，**必须**定义其下线流程。
      * **引入破坏性变更：** 当破坏性变更成为必要时，API **应该**创建新的主要版本。
* **例外情况：**
  * **孤立变更：** 在极少数情况下，如果一个小而孤立的破坏性变更对整体益处更大（例如，只影响极少数用户），则**可以**进行，但需在正常下线期内继续支持旧组件。
  * **紧急变更：** 在安全问题或法规要求等紧急情况下，任何 API 组件**可以**以破坏性方式进行更改，不承诺弃用期。

## AIP-193：错误 (Errors)

* **核心概念：** 定义了标准化 API 错误响应的结构和处理方式，以提高客户端的错误处理效率和用户体验。
* **错误响应结构：** 服务**必须**返回 `google.rpc.Status` 消息，并**必须**使用 `google.rpc.Code` 中定义的标准错误代码。
* **`Status.message` 字段：**
  * **面向开发者：** 是面向开发者的、人类可读的“调试消息”，**应该**使用英文。
  * **稳定性：** 如果错误响应始终包含机器可读的 `ErrorInfo`，`Status.message` 的内容**可以**随时间更改；否则，**必须**保持稳定。
* **`Status.code` 字段：** **必须**是 `google.rpc.Code` 枚举中的某个数值。服务**不得**添加自定义错误代码。
* **`Status.details` 字段：**
  * **附加信息：** 允许包含额外的错误信息消息（封装在 `google.protobuf.Any` 中）。
  * **强制包含 `ErrorInfo`：** 所有错误响应**必须**在 `details` 中包含 `ErrorInfo` 负载，以提供机器可读的标识符。
* **`ErrorInfo` 字段：**
  * **机器可读标识符：** 是发送机器可读标识符的主要方式。
  * **`reason`：** 错误原因的简短 `snake_case` 描述，在特定错误域内唯一。
  * **`domain`：** `reason` 所属的逻辑分组，通常是生成错误的服务的名称（例如 `pubsub.googleapis.com`）。
  * **`(reason, domain)` 对：** 构成识别特定错误的机器可读方式，对于相同的错误**必须**保持一致。
  * **`metadata`：** 键值对映射，提供额外的动态上下文信息。
* **`LocalizedMessage` 字段：** 用于提供本地化（用户语言）的错误消息。
* **`Help` 字段：** 当需要额外文档或多重故障排除点时，**必须**在 `Help` 负载中提供补充文档的 URL。
* **部分错误：** 通常**不被鼓励**，因为它们会增加客户端复杂性。但在批量操作中，可以通过长时间运行操作的元数据来报告部分失败。
* **权限和存在性检查：**
  * 如果用户没有权限，服务**必须**返回 `PERMISSION_DENIED` (HTTP 403)，且权限检查**必须**在资源存在性检查之前。
  * 如果用户有权限但资源不存在，服务**必须**返回 `NOT_FOUND` (HTTP 404)。

## AIP-210：Unicode

* **核心概念：** 定义 API 中字符串值的正确处理方式，尤其是在长度限制、计量和唯一性方面，以应对 Unicode 的复杂性。
* **“字符”的定义：** 在 API 中，“字符”**必须**定义为 Unicode 码点（Code Point）。
* **长度单位：** 所有字符串字段的长度限制**必须**以码点为单位测量和执行。
* **计费/配额单位：** API **可以**使用码点或字节（UTF-8 编码）作为计费或配额的单位。如果未明确定义，默认计为**字符（码点）**。
* **唯一标识符 (Unique Identifiers)：**
  * **字符限制：** **应该**限制为 ASCII 字符（`[a-zA-Z][a-zA-Z0-9_-]*`），且不以数字开头，以避免规范化问题。
  * **Unicode 标识符：** 如果允许所有 Unicode 字符作为标识符，API **必须**拒绝任何不符合 Normalization Form C (NFC) 的输入。
  * **长度：** 通常**应该**使用最大长度 64 个字符。
* **规范化 (Normalization)：**
  * Unicode 字符串值**应该**存储在 [Normalization Form C (NFC)](https://unicode.org/reports/tr15/) 中。
  * 对于唯一识别目的（如 `name`, `id`），值**必须**规范化为 NFC。

## AIP-216：状态 (States)

* **核心概念：** 提供关于在 API 中设计和表示资源状态的指南，确保状态表示的清晰、一致性和可管理性。
* **表示方式：** 需要通信其状态的资源**应该**使用 Protobuf 枚举来表示状态。
* **命名约定：**
  * **枚举名：** **应该**命名为 `State`，或以 `State` 结尾（例如 `VmState`）。
  * **嵌套：** 如果枚举仅在单个消息中使用，**应该**嵌套在该消息内部。
  * **枚举值：**
    * **零值：** 第一个值（零值）**应该**是 `STATE_UNSPECIFIED = 0`，不应用于实际状态。
    * **通用术语：** 使用标准化术语：
      * **静止状态 (Resting states)：** 预计会无限期保持（例如 `ACTIVE`, `DELETED`, `SUCCEEDED`, `FAILED`）。
      * **活动状态 (Active states)：** 通常会自行解析为其他状态（例如 `CREATING`, `DELETING`, `RUNNING`, `PENDING`）。
* **只暴露有用状态：** 仅添加对客户端有用的状态，避免暴露过多的内部实现细节。每个状态都应有明确的用例。
* **只输出 (Output Only)：**
  * 引用 `State` 枚举的字段**应该**是“只输出”字段。
  * **不应**允许通过 `Update` 方法直接更新状态，而**应该**使用特定的状态转换方法。
* **状态转换方法 (State Transition Methods)：**
  * 状态转换通常通过特定的自定义 RPC 方法实现，而不是直接更新状态字段。
  * **RPC 命名：** 通常为动词 + 资源消息名称（例如 `PublishBook`）。
  * **HTTP 动词：** **必须**是 `POST`。
  * **URI 后缀：** **必须**使用 `:` 字符后跟自定义动词（例如 `:publish`）。
  * **响应：** 通常返回转换后的资源本身。如果长时间运行，则返回 `google.longrunning.Operation`。
  * **错误：** 如果状态转换不允许，服务**必须**返回 `FAILED_PRECONDITION` (HTTP 400) 错误。
* **兼容性：** 添加新的状态枚举值**不被认为是破坏性更改**，但应鼓励客户端编写代码以处理将来可能接收到的新值。
